package com.leecode.test;

/**
 * Created by asns on 2022/3/16.
 * 同一个包下的相互应用不需要import
 * 给你一个 严格升序排列 的正整数数组 arr 和一个整数 k 。
 * 请你找到这个数组里第 k 个缺失的正整数
 * 这个题目默认数组中数据的大小不超过2000个
 * 他实际上是这样表示的   就是数组中数据的大小小于1000
 * 同时k的大小也小于1000
 */

/**
 * 解题思路
 * 建立一个新数组，将原数组中的数作为新数组的下标，并且将对应下标中的元素置为1，
 * 这样新数组中元素为1的下标即为出现的正整数，元素为0的下标即为缺失的正整数。
 * 然后从下标1开始遍历，计数0的个数，第k个0对应的下标即为第k个缺失的正整数。
 */
public class Leecode1539_QueshiK {
    public int foundint(int[] arr,int n)
    {
//        int i= arr.length;
        //问题时如何新建和数组中最大值，也就是最后一个值大小的数组呢，这里明显是
        //做不到的，因为会显示一个变量，变量是无法定义数组的
        //这里的一个简单的办法，去超级大的值，或使用list
//        int j = arr[j];
        //所以第一步，定义一个大小是 2000的数组
        int[] tis= new int[2001];//这里的2001实际上是按照题目的要求，因为是从1开始，而数组是从0
        //开始所以需要这样加上一
        int num = 0;//计数器
        int temp =0 ;//返回值
        for (int i=0;i<arr.length;i++)
        {
           tis[arr[i]]=1;//就是arr[i]中有具体数值的是1，没有具体数值的变成0
            //这个可不可以用if来实现，应该是可以的
//            if(arr[i]!=0)
//            {
//                tis[arr[i]]=1;
//            }
//            else tis[arr[i]]=0;
            //显然这种也可以但是不够速度快，因为之前学到的知识，tis在声明的时候，因为没有初始化，
            //所以内部所有元素都是0
        }
        for (int i=1;i<2001;i++)//为什么这里从1开始？，因为第一个元素的零是不被认可的，缺失是从1开始的
        {
            if(tis[i]!=0){
                continue;//利用continue结束当层循环的功能
            }
            else num++;
            if (num==n)
            {
                temp=i;//这里是要等于i 的不是等于n的，不是让等价于输入值，而是让等于移动到的位置
                //实际上是记录的i的循环的位置，也就是数组下标对应位置的值
                break;
            }
        }
        return temp;

    }
}
